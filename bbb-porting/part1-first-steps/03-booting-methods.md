## Let's try these alternate methods for booting the board

### Factory boot

Quickly testing your board with factory kernel image, rootfs

### Custom kernel and rootfs on second part of eMMC

If you don't have a rootfs image initially,this is convenient to test your custom kernel against factory rootfs in eMMC with well defined utilities, For this set the boot parameters as follows

`setenv bootargs 'console=ttyO0,115200n8 root=/dev/mmcblk0p2 rw rootfstype=ext4 rootwait` assuming  no SD card is present

### Custom kernel and rootfs on second part of SD card.

This is most convenient for frequent updations on rootfs, for this extract the contents of rootfs image into 2nd part of SD card and set the boot params as follows

`setenv bootargs 'console=ttyO0,115200n8 root=/dev/mmcblk0p2 rw rootfstype=ext4 rootwait`

Note:- 1.If SD card is connected to the board, SD card partitions are represented as /dev/mmcblk0p1, /dev/mmcblk0p2 and eMMC partitions are represented as /dev/mmcblk1boot, /dev/mmcblk1p2.

2.When there is no SD card is connected, /dev/mmcblk0p1,/dev/mmcblk0p2 represents eMMC partitions.

3.Best way to ensure above device file names is...boot the target once with factory kernel(auto boot) and check the entries in /dev directory.

### Loading kernel image, dtb file, initrd.img via TFTP from Host PC

This is convinient for initial testing and eliminating the use of accessories like SD card and card reader.

Ensure TFTP server is installed on host PC, and configure `~/eworkdir/deploy` as TFTP root, in which zImage, dtb,rootfs image are available

Connect the target board and Host PC using a LAN cable and assign a suitable ip address to ethernet interface of host PC

`ifconfig eth0 192.168.x.y`

Stop the autoboot thru minicom to enter u-boot console,and follow these steps to boot the target

`setenv ipaddr 192.168.x.z`

`setenv serverip 192.168.x.y`    #Choose 192.168.x.y, 192.168.x.z suitably

`ping 192.168.x.y`

`tftp 0x88080000 myrootfs.img` #note down the size

`tftp 0x82000000 zImage`

`tftp 0x88000000 am335x-boneblack.dtb`

`setenv bootargs 'console=ttyO0,115200n8 root=/dev/ram0 rw initrd=0x88080000,<size>'`

(or)

`setenv bootargs 'console=ttyO0,115200n8 root=/dev/mmcblk0p2 rw rootfstype=ext4 rootwait`

`bootz 0x82000000 - 0x88000000`

### Working with uImage instead of zImage

Even though *zImage* is accepted by recent *u-boot* versions and loaded with the help of *bootz* command,some previous u-boot versions won't not allow zImage and expect *uImage* generated by `mkimage` utility wrapped with **LOADADDRESS**, and such *uImage* is loaded by *bootm* command, Let's follow these steps to work with *uImage*


For recent ubuntu distributions(checked on 16.04) *mkimage* is available through the package *u-boot-tools*, so you can get it with the following command

`sudo apt-get install u-boot-tools`

But *mkimage* utility is not available through package managers of many other distributions,in such distros we need to build the u-boot source code (full build or tools-only) to generate *mkimage* utility

Download any recent stable version of u-boot from ftp://ftp.denx.de/pub/u-boot/, in the form of u-boot-yyyy.mm.tar.bz2, where yyyy, mm represents year & month of latest release (u-boot-latest.tar.bz2 always link to recent stable version)

Extract the u-boot source tar ball

`tar -jxvf u-boot-yyyy.mm.tar.bz2`    

`cd u-boot-yyyy.mm`                                #let's call it as USRC for current work

`make tools-only`

`cp tools/mkimage /usr/local/bin` (or) `ln -s $PWD/tools/mkimage /usr/local/bin`

Now while building kernel source, after the generation of zImage, let's run the following step to generate uImage

`make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- uImage LOADADDR=0x80008000`

This step transforms zImage into uImage as follows (just for your reference,no need to run this,you can also notice this command syntax at the end of above step)

`mkimage -A arm -O linux -C none -T kernel -a 0x80008000 -e 0x80008000 -n 'Linux-4.x.x-BBB' -d zImage uImage`

Now collect the `arch/boot/uImage` and use accordingly,i.e. using *tftp* or *fatload* load the *uImage* instead of *zImage* and replace *bootz* by *bootm*

`bootm 0x82000000 - 0x88000000`

### Auto boot with custom kernel using uEnv command

### Auto boot with boot.scr (TODO)

Note:- we are using factory u-boot loaded in eMMC part1 till now, you may try some steps later to work with your own bootloader.(TODO)
